

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   	boolean errorDetected;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      errorDetected = true;
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    	errorDetected = true;
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
		
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal READ, PRINT, NEW, RETURN, INC, DEC, EQUAL, PLUS, MINUS, DIV, MUL, MOD;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, FOR, CONTINUE, BREAK;
terminal PROG, CONST, SEMI, COMMA, DOT, VOID, ENUM;
terminal OR, AND, EQ, NEQ, GT, GTE, LT, LTE, IF, ELSE;

terminal String IDENT;
terminal Integer NUMBER;
terminal String CHAR;
terminal String BOOL;

nonterminal Statement Statement;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal VarType VarType;
nonterminal ConstType ConstType;
nonterminal ActualPars ActualPars;
nonterminal ActualParamList ActualParamList;
nonterminal DeclarationLists DeclarationLists;
nonterminal MinusSign MinusSign;
nonterminal DeclarationList DeclarationList;
nonterminal Declaration Declaration;
nonterminal ListVarDeclTypeList ListVarDeclTypeList;
nonterminal VarDeclTypeList VarDeclTypeList;
nonterminal VarDeclList VarDeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal ReturnStatement ReturnStatement;
nonterminal ConstDeclList ConstDeclList;
nonterminal EnumDeclList EnumDeclList;
nonterminal VarDecl VarDecl;
nonterminal EnumDecl EnumDecl;
nonterminal ConstDecl ConstDecl;
nonterminal StatementList StatementList;
nonterminal FormalParamList FormalParamList;
nonterminal FormPars FormPars;
nonterminal FormalParamDecl FormalParamDecl;
 
nonterminal InnerStatementList InnerStatementList;
nonterminal ForStatement ForStatement;
nonterminal ForDesignatorStatement ForDesignatorStatement;
nonterminal ForCondition ForCondition;
nonterminal Relop Relop;
nonterminal AfterForDesignatorStatement AfterForDesignatorStatement;
nonterminal BreakStatement BreakStatement;
nonterminal ContinueStatement ContinueStatement;
nonterminal Matched Matched;
nonterminal Unmatched Unmatched;
nonterminal IfStatement IfStatement;
nonterminal ElseStatement ElseStatement;
nonterminal IfCondition IfCondition;
nonterminal NewArrayExpression NewArrayExpression;
nonterminal InitializerListStart InitializerListStart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl, MethodTypeName, Designator, Program, ProgName, EnumName, FuncName, DesignatorName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, DesignatorStatement, SignedTerm, Expr, Term, Factor, Condition, CondTerm, CondFact, InitializerList;

precedence left ELSE;
Program ::= (Program) PROG ProgName:p DeclarationLists:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, D1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

DeclarationLists ::= (DeclarationLists) DeclarationList:D1 {: RESULT=new DeclarationLists(D1); RESULT.setLine(D1left); :};

DeclarationList ::= (ProgDeclList) DeclarationList:D1 Declaration:D2 {: RESULT=new ProgDeclList(D1, D2); RESULT.setLine(D1left); :}
				|
				(NoProgDeclList) {: RESULT=new NoProgDeclList(); :} /* epsilon */
				;

ConstType ::= (ConstType) Type:typeName {: RESULT=new ConstType(typeName); RESULT.setLine(typeNameleft); :};

EnumName ::= (EnumName) IDENT:enumName {: RESULT=new EnumName(enumName); RESULT.setLine(enumNameleft); :};

Declaration ::= (ConstDeclaration) CONST ConstType:constType ConstDeclList:C1 SEMI {: RESULT=new ConstDeclaration(constType, C1); RESULT.setLine(constTypeleft); :}
			|
			(VarDeclaration) VarDeclTypeList:V1 {: RESULT=new VarDeclaration(V1); RESULT.setLine(V1left); :} 
			|
			(EnumDeclaration) ENUM EnumName:enumName LBRACE EnumDeclList:E1 RBRACE {: RESULT=new EnumDeclaration(enumName, E1); RESULT.setLine(enumNameleft); :}
			;

ListVarDeclTypeList ::= (ListVarDeclTypeLists) ListVarDeclTypeList:L1 VarDeclTypeList:V2 {: RESULT=new ListVarDeclTypeLists(L1, V2); RESULT.setLine(L1left); :}
					|
					(NoListVarDeclTypeLists) {: RESULT=new NoListVarDeclTypeLists(); :} /* epsilon */
					;
					
VarType ::= (VarType)Type:typeName {: RESULT=new VarType(typeName); RESULT.setLine(typeNameleft); :};

VarDeclTypeList ::= (VarDeclarationTypeList) VarType:varType VarDeclList:V1 SEMI {: RESULT=new VarDeclarationTypeList(varType, V1); RESULT.setLine(varTypeleft); :}
				|
				(ErrorNumDecl) error SEMI:l {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ErrorNumDecl(); :}	
			;

VarDeclList ::= (VarDeclarations) VarDeclList:V1 COMMA VarDecl:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}				
		   	|
			(SingleVarDeclaration) VarDecl:V1 {: RESULT=new SingleVarDeclaration(V1); RESULT.setLine(V1left); :}	
			;

VarDecl ::= (SingleVarDecl) IDENT:varName {: RESULT=new SingleVarDecl(varName); RESULT.setLine(varNameleft); :}
			|
			(VarDeclArray) IDENT:varName LBRACKET RBRACKET {: RESULT=new VarDeclArray(varName); RESULT.setLine(varNameleft); :} 
			|
			(ErrorDecl) error:l  {: parser.report_error("Izvrsen oporavak u liniji " + lleft, null);  :} {: RESULT=new ErrorDecl(); :}

			;

EnumDeclList ::= (EnumDeclarations) EnumDeclList:E1 COMMA EnumDecl:E2 {: RESULT=new EnumDeclarations(E1, E2); RESULT.setLine(E1left); :}
			|
			(SingleEnumDeclarations) EnumDecl:E1 {: RESULT=new SingleEnumDeclarations(E1); RESULT.setLine(E1left); :}
			;

EnumDecl ::= (SingleEnumDecl) IDENT:literalName {: RESULT=new SingleEnumDecl(literalName); RESULT.setLine(literalNameleft); :}
			|
			(EnumDeclEqual) IDENT:literalName EQUAL NUMBER:N1 {: RESULT=new EnumDeclEqual(literalName, N1); RESULT.setLine(literalNameleft); :}
			;

ConstDeclList ::= (ConstDeclarations) ConstDeclList:C1 COMMA ConstDecl:C2 {: RESULT=new ConstDeclarations(C1, C2); RESULT.setLine(C1left); :}
				|
				(SingleConstDeclaration) ConstDecl:C1 {: RESULT=new SingleConstDeclaration(C1); RESULT.setLine(C1left); :}
				;

MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMethodDecl) {: RESULT=new NoMethodDecl(); :} /* epsilon */
				;			

MethodTypeName ::= (MethodVoidTypeName) VOID IDENT:methName {: RESULT=new MethodVoidTypeName(methName); RESULT.setLine(methNameleft); :}
				|
				(MethodNoVoidTypeName) Type:retType IDENT:methName {: RESULT=new MethodNoVoidTypeName(retType, methName); RESULT.setLine(retTypeleft); :}
				;

MethodDecl ::= (MethodDecl) MethodTypeName:M1 LPAREN FormPars:F2 RPAREN ListVarDeclTypeList:L3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(M1, F2, L3, S4); RESULT.setLine(M1left); :};

FormPars ::= (FormParams) FormalParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :}
		  |
		  (NoFormParam) {: RESULT=new NoFormParam(); :} /* epsilon */
		  ;
		  
FormalParamList ::= (FormalParamDecls) FormalParamList:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamDecls(F1, F2); RESULT.setLine(F1left); :}
				|
				(SingleFormalParamDecl) FormalParamDecl:F1 {: RESULT=new SingleFormalParamDecl(F1); RESULT.setLine(F1left); :}
				;

FormalParamDecl ::= (ParamDecl) Type:type IDENT:name {: RESULT=new ParamDecl(type, name); RESULT.setLine(typeleft); :}
					|
					(ArrayParamDecl) Type:type IDENT:name LBRACKET RBRACKET {: RESULT=new ArrayParamDecl(type, name); RESULT.setLine(typeleft); :}
					|
					(FormalParamDeclError) error:l {: parser.report_error("Izvrsen oporavak u liniji " + lleft , null );  :} {: RESULT=new FormalParamDeclError(); :}	
					;
					
ConstDecl ::= (NumConstDecl) IDENT:constName EQUAL NUMBER:N1 {: RESULT=new NumConstDecl(constName, N1); RESULT.setLine(constNameleft); :}
			|
			(CharConstDecl) IDENT:constName EQUAL CHAR:C1 {: RESULT=new CharConstDecl(constName, C1); RESULT.setLine(constNameleft); :}
			|
			(BoolConstDecl) IDENT:constName EQUAL BOOL:B1 {: RESULT=new BoolConstDecl(constName, B1); RESULT.setLine(constNameleft); :}
			;
	
StatementList ::= (StmtDeclarations) StatementList:S1 Statement:S2 {: RESULT=new StmtDeclarations(S1, S2); RESULT.setLine(S1left); :}
				|
				(NoStmtDeclarations) {: RESULT=new NoStmtDeclarations(); :} /* epsilon */
				;	

InnerStatementList ::= (InnerStmtList) InnerStatementList:I1 Statement:S2 {: RESULT=new InnerStmtList(I1, S2); RESULT.setLine(I1left); :}
					|
					(NoInnerStmt) {: RESULT=new NoInnerStmt(); :} /*epsilon*/
					;
Statement ::= (MatchedStmt) Matched:M1 {: RESULT=new MatchedStmt(M1); RESULT.setLine(M1left); :}
		   |
		   (UnmatchedStmt) Unmatched:U1 {: RESULT=new UnmatchedStmt(U1); RESULT.setLine(U1left); :}
		   ; 


Unmatched ::= (UnmatchedIf) IfStatement:I1 LPAREN IfCondition:I2 RPAREN Statement:S3 {: RESULT=new UnmatchedIf(I1, I2, S3); RESULT.setLine(I1left); :}
		 	|
		 	(UnmatchedIfElse) IfStatement:I1 LPAREN IfCondition:I2 RPAREN Matched:M3 ElseStatement:E4 Unmatched:U5 {: RESULT=new UnmatchedIfElse(I1, I2, M3, E4, U5); RESULT.setLine(I1left); :}
		 	|
		 	(MatchedIfElse) IfStatement:I1 LPAREN IfCondition:I2 RPAREN Matched:M3 ElseStatement:E4 Matched:M5 {: RESULT=new MatchedIfElse(I1, I2, M3, E4, M5); RESULT.setLine(I1left); :}
		 	;
IfStatement ::= (If) IF {: RESULT=new If(); :};
ElseStatement::= (Else) ELSE {: RESULT=new Else(); :};
IfCondition ::= (IfCond) Condition:C1 {: RESULT=new IfCond(C1); RESULT.setLine(C1left); :}
				|
				(IfConditionError) error:l {: parser.report_error("Izvrsen oporavak u liniji " + lleft , null );  :} {: RESULT=new IfConditionError(); :}	
				;

Matched ::= 
			(DesignatorStmt) DesignatorStatement:D1 SEMI {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
			| 
			(AssignmentExprError) error SEMI:l
			{: parser.report_error("Izvrsen oporavak u liniji " + lleft , null );  :} {: RESULT=new AssignmentExprError(); :}	
			|
			(ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
			| 
			(PrintStmt) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new PrintStmt(E1); RESULT.setLine(E1left); :}
			|
			(PrintNumStmt) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new PrintNumStmt(E1, N2); RESULT.setLine(E1left); :}
			|
			(ReturnStmt) ReturnStatement:R1 Expr:e SEMI {: RESULT=new ReturnStmt(R1, e); RESULT.setLine(R1left); :}
			|
			(ReturnNoExpr) ReturnStatement:R1 SEMI {: RESULT=new ReturnNoExpr(R1); RESULT.setLine(R1left); :}
			|
			(ForStmt) ForStatement:F1 LPAREN ForDesignatorStatement:F2 SEMI ForCondition:F3 SEMI AfterForDesignatorStatement:A4 RPAREN Statement:S5 {: RESULT=new ForStmt(F1, F2, F3, A4, S5); RESULT.setLine(F1left); :}
			|
			(InnerStatement) LBRACE InnerStatementList:I1 RBRACE {: RESULT=new InnerStatement(I1); RESULT.setLine(I1left); :}
			|
			(BreakStmt) BreakStatement:B1 SEMI {: RESULT=new BreakStmt(B1); RESULT.setLine(B1left); :}
			|
			(ContinueStmt) ContinueStatement:C1 SEMI {: RESULT=new ContinueStmt(C1); RESULT.setLine(C1left); :}
			;		
ReturnStatement ::= (ReturnStatement) RETURN {: RESULT=new ReturnStatement(); :};
BreakStatement ::= (BreakStatement) BREAK {: RESULT=new BreakStatement(); :};
ContinueStatement ::= (ContinueStatement) CONTINUE {: RESULT=new ContinueStatement(); :};
		
ForStatement ::= (For) FOR:forst {: RESULT=new For(); :};
			
ForDesignatorStatement ::= (ForDesignatorStmt) DesignatorStatement:s {: RESULT=new ForDesignatorStmt(s); RESULT.setLine(sleft); :}
						|
						(NoForDesignatorStmt) {: RESULT=new NoForDesignatorStmt(); :}/* epsilon */
						;

AfterForDesignatorStatement ::= (AfterForDesignatorStmt) DesignatorStatement:s {: RESULT=new AfterForDesignatorStmt(s); RESULT.setLine(sleft); :}
						|
						(NoAfterForDesignatorStmt) {: RESULT=new NoAfterForDesignatorStmt(); :}/* epsilon */
						;
							
				
ForCondition ::= (ForCntd) Condition:C1 {: RESULT=new ForCntd(C1); RESULT.setLine(C1left); :}
				|
				(NoForCndt) {: RESULT=new NoForCndt(); :} /* epslion */
				;

Condition ::= (OrCondition) Condition:C1 OR CondTerm:C2 {: RESULT=new OrCondition(C1, C2); RESULT.setLine(C1left); :}	
				|
				(SingleCondTerm) CondTerm:C1 {: RESULT=new SingleCondTerm(C1); RESULT.setLine(C1left); :}
				;				
				
CondTerm ::= (AndCondition) CondTerm:C1 AND CondFact:C2 {: RESULT=new AndCondition(C1, C2); RESULT.setLine(C1left); :}
			|
			(SingleCondFact) CondFact:C1 {: RESULT=new SingleCondFact(C1); RESULT.setLine(C1left); :}
			;
			
CondFact ::= (RelopExpr) CondFact:C1 Relop:R2 Expr:E3 {: RESULT=new RelopExpr(C1, R2, E3); RESULT.setLine(C1left); :}
			 |
			 (SingleExpr) Expr:E1 {: RESULT=new SingleExpr(E1); RESULT.setLine(E1left); :}
			 ;
			 

		   		
DesignatorStatement ::=(Assignment) Designator:dest EQUAL Expr:e {: RESULT=new Assignment(dest, e); RESULT.setLine(destleft); :} 
					|
					(Increment) Designator:dest INC {: RESULT=new Increment(dest); RESULT.setLine(destleft); :}
					|
					(Decrement) Designator:dest DEC {: RESULT=new Decrement(dest); RESULT.setLine(destleft); :}
					|
					(ProcCall) FuncName:name LPAREN ActualPars:A1 RPAREN {: RESULT=new ProcCall(name, A1); RESULT.setLine(nameleft); :}
					;

Expr ::= (AddopExpr) Expr:e Addop:A1 Term:t {: RESULT=new AddopExpr(e, A1, t); RESULT.setLine(eleft); :}
			|
			(TermExpr) SignedTerm:e {: RESULT=new TermExpr(e); RESULT.setLine(eleft); :}
			;
SignedTerm::= (MinusTerm) MINUS Term:t {: RESULT=new MinusTerm(t); RESULT.setLine(tleft); :}
			|
			(PlusTerm) Term:t {: RESULT=new PlusTerm(t); RESULT.setLine(tleft); :}
			;	
	/*		
SignedExpr ::= (AddopExpr) SignedExpr:te Addop Term:t
		|
		(TermExpr) Term:t
		;*/

Term ::= (MulopTerm) Term:t Mulop:M1 Factor:f {: RESULT=new MulopTerm(t, M1, f); RESULT.setLine(tleft); :}
		|
		(FactorTerm) Factor:f {: RESULT=new FactorTerm(f); RESULT.setLine(fleft); :}
		;

FuncName ::= (FuncName) Designator:d {: RESULT=new FuncName(d); RESULT.setLine(dleft); :};

Factor ::= (NumConstFact) NUMBER:N1 {: RESULT=new NumConstFact(N1); RESULT.setLine(N1left); :} 
			|
			(CharConstFact) CHAR:C1 {: RESULT=new CharConstFact(C1); RESULT.setLine(C1left); :}
			|
			(ExprFact) LPAREN Expr:E1 RPAREN {: RESULT=new ExprFact(E1); RESULT.setLine(E1left); :}
			|
			(BoolConstFact) BOOL:B1 {: RESULT=new BoolConstFact(B1); RESULT.setLine(B1left); :}
			|
			(NewFact) NEW Type:T1 {: RESULT=new NewFact(T1); RESULT.setLine(T1left); :}
			|
			(NewExprFact) NewArrayExpression:N1 {: RESULT=new NewExprFact(N1); RESULT.setLine(N1left); :}
			|
			(NewExprFactInit) NewArrayExpression:N1 InitializerListStart:I2 InitializerList:I3 RBRACE {: RESULT=new NewExprFactInit(N1, I2, I3); RESULT.setLine(N1left); :}
			|
			(Var) Designator:d {: RESULT=new Var(d); RESULT.setLine(dleft); :}
			|
			(FuncCall) FuncName:name LPAREN ActualPars:A1 RPAREN {: RESULT=new FuncCall(name, A1); RESULT.setLine(nameleft); :} 
			;
InitializerListStart ::= (InitListStart) LBRACE {: RESULT=new InitListStart(); :};
NewArrayExpression ::= (NewArrayExpr) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new NewArrayExpr(T1, E2); RESULT.setLine(T1left); :};	
InitializerList ::= (InitList) InitializerList:I1 COMMA Expr:E2 {: RESULT=new InitList(I1, E2); RESULT.setLine(I1left); :}
					|
					(Initializer) Expr:E1 {: RESULT=new Initializer(E1); RESULT.setLine(E1left); :}
					;
					
ActualPars ::= (Actuals) ActualParamList:A1 {: RESULT=new Actuals(A1); RESULT.setLine(A1left); :}
			|
			(NoActuals) {: RESULT=new NoActuals(); :} /* epsilon */
			;
		
ActualParamList ::= (ActualParams) ActualParamList:A1 COMMA Expr:E2 {: RESULT=new ActualParams(A1, E2); RESULT.setLine(A1left); :}
				|
				(ActualParam) Expr:E1 {: RESULT=new ActualParam(E1); RESULT.setLine(E1left); :}
				;
	
Addop ::= (PlusAddop) PLUS {: RESULT=new PlusAddop(); :}
		|
		(MinusAddop) MINUS {: RESULT=new MinusAddop(); :}
		;

Mulop ::= (MulMulop) MUL {: RESULT=new MulMulop(); :}
		|
		(DivMulop) DIV {: RESULT=new DivMulop(); :}
		| 
		(ModMulop) MOD {: RESULT=new ModMulop(); :}
		;
		
Relop ::= (EqRelop) EQ {: RESULT=new EqRelop(); :}
		|
		(NeqRelop) NEQ {: RESULT=new NeqRelop(); :}
		|
		(GtRelop) GT {: RESULT=new GtRelop(); :}
		|
		(GteRelop) GTE {: RESULT=new GteRelop(); :}
		|
		(LtRelop) LT {: RESULT=new LtRelop(); :}
		|
		(LteRelop) LTE {: RESULT=new LteRelop(); :}
		;
		
DesignatorName ::= (DesignatorName) IDENT:name {: RESULT=new DesignatorName(name); RESULT.setLine(nameleft); :};
Designator ::= (IdentDesign) IDENT:name {: RESULT=new IdentDesign(name); RESULT.setLine(nameleft); :}
			|
			(SubIdendDesign) IDENT:name DOT IDENT:subName {: RESULT=new SubIdendDesign(name, subName); RESULT.setLine(nameleft); :}
			|
			(ArrIdentDesign) DesignatorName:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new ArrIdentDesign(D1, E2); RESULT.setLine(D1left); :}
			;
			
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};